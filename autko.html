<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>RPi Car Control</title>
        <style>
            :root {
                --primary-bg: #1a1a1a;
                --secondary-bg: #2c2c2c;
                --tertiary-bg: #3f3f3f;
                --primary-text: #e0e0e0;
                --accent-color: #007bff;
                --accent-hover: #0056b3;
                --danger-color: #dc3545;
                --danger-hover: #c82333;
                --success-color: #28a745;
                --success-hover: #218838;
                --border-color: #4a4a4a;
                --font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            }

            * {
                box-sizing: border-box;
            }

            body {
                background-color: var(--primary-bg);
                color: var(--primary-text);
                font-family: var(--font-family);
                margin: 0;
                padding: 15px;
            }

            .main-container {
                display: flex;
                gap: 15px;
                width: 100%;
                max-width: 1200px;
                margin: 0 auto;
            }

            .feed-section {
                flex: 1;
                min-width: 0;
            }

            .controls-column {
                flex: 1;
                min-width: 400px;
            }

            .controls-row {
                display: flex;
                gap: 10px;
                margin-bottom: 10px;
            }

            .controls-row .control-group {
                flex: 1;
                margin-bottom: 0;
            }

            .panel {
                background-color: var(--secondary-bg);
                border-radius: 8px;
                padding: 15px;
            }

            #mjpegStream {
                width: 100%;
                border-radius: 6px;
                background: #000;
                height: auto;
                object-fit: contain;
            }

            .control-group {
                background-color: var(--tertiary-bg);
                padding: 12px;
                border-radius: 6px;
                margin-bottom: 10px;
            }

            .control-group h3 {
                margin: 0 0 10px 0;
                color: var(--primary-text);
                font-size: 1em;
                font-weight: 500;
            }

            .buttons-grid {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                grid-template-rows: repeat(3, auto);
                gap: 8px;
                align-items: center;
                justify-items: center;
            }

            .buttons-grid button {
                width: 100%;
                min-height: 50px;
                font-size: 1.1em;
                font-weight: bold;
                background-color: var(--accent-color);
                color: white;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                transition:
                    background-color 0.15s,
                    transform 0.1s;
                display: flex;
                align-items: center;
                justify-content: center;
                user-select: none;
                -webkit-tap-highlight-color: transparent;
            }

            .buttons-grid button:hover {
                background-color: var(--accent-hover);
            }

            .buttons-grid button:active {
                transform: scale(0.95);
            }

            .stop-button {
                grid-column: 2;
                grid-row: 2;
                background-color: var(--danger-color) !important;
            }

            .stop-button:hover {
                background-color: var(--danger-hover) !important;
            }

            .button-w {
                grid-column: 2;
                grid-row: 1;
            }
            .button-a {
                grid-column: 1;
                grid-row: 2;
            }
            .button-s {
                grid-column: 2;
                grid-row: 3;
            }
            .button-d {
                grid-column: 3;
                grid-row: 2;
            }

            .camera-button {
                font-size: 1.8em !important;
                background-color: var(--success-color) !important;
            }

            .camera-button:hover {
                background-color: var(--success-hover) !important;
            }

            #camera-up {
                grid-column: 2;
                grid-row: 1;
            }
            #camera-left {
                grid-column: 1;
                grid-row: 2;
            }
            #camera-center {
                grid-column: 2;
                grid-row: 2;
                background-color: var(--accent-color) !important;
            }
            #camera-center:hover {
                background-color: var(--accent-hover) !important;
            }
            #camera-right {
                grid-column: 3;
                grid-row: 2;
            }
            #camera-down {
                grid-column: 2;
                grid-row: 3;
            }

            input[type="range"] {
                width: 100%;
                accent-color: var(--accent-color);
            }

            .gamepad-status {
                font-size: 0.9em;
                padding: 8px;
                text-align: center;
                word-break: break-word;
            }

            #connectGamepadButton {
                width: 100%;
                padding: 12px;
                font-size: 1.1em;
                font-weight: 500;
                background-color: var(--success-color);
                color: white;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                transition: background-color 0.2s;
                margin-top: 10px;
            }

            #connectGamepadButton:hover {
                background-color: var(--success-hover);
            }

            .status-connected {
                color: #4ade80;
            }
            .status-disconnected {
                color: #f87171;
            }
        </style>
    </head>
    <body>
        <div class="main-container">
            <section class="panel feed-section">
                <div class="control-group">
                    <h2>Live Feed</h2>
                    <img id="mjpegStream" src="/mjpeg" alt="Camera Feed" />
                </div>
            </section>

            <section class="panel controls-column">
                <div class="controls-row">
                    <div class="control-group">
                        <h3>Movement</h3>
                        <div class="buttons-grid">
                            <button class="button-w" data-key="w">W</button>
                            <button class="button-a" data-key="a">A</button>
                            <button class="stop-button" data-key="stop">
                                STOP
                            </button>
                            <button class="button-s" data-key="s">S</button>
                            <button class="button-d" data-key="d">D</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <h3>Camera Control</h3>
                        <div class="buttons-grid">
                            <button
                                class="camera-button"
                                id="camera-up"
                                data-direction="up"
                            >
                                ↑
                            </button>
                            <button
                                class="camera-button"
                                id="camera-left"
                                data-direction="left"
                            >
                                ←
                            </button>
                            <button
                                class="camera-button"
                                id="camera-center"
                                data-direction="center"
                            >
                                ⌂
                            </button>
                            <button
                                class="camera-button"
                                id="camera-right"
                                data-direction="right"
                            >
                                →
                            </button>
                            <button
                                class="camera-button"
                                id="camera-down"
                                data-direction="down"
                            >
                                ↓
                            </button>
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <h3>Status: <span id="motorStatus">Connecting...</span></h3>
                </div>

                <div class="controls-row">
                    <div class="control-group">
                        <h3>Speed: <span id="speedValue">50</span>%</h3>
                        <input
                            type="range"
                            id="speedSlider"
                            min="0"
                            max="100"
                            value="50"
                        />
                    </div>
                    <div class="control-group">
                        <h3>
                            Camera Speed: <span id="cameraSpeedValue">5</span>
                        </h3>
                        <input
                            type="range"
                            id="cameraSpeedSlider"
                            min="2"
                            max="10"
                            value="5"
                        />
                    </div>
                </div>

                <div class="control-group">
                    <h3>Gamepad</h3>
                    <button id="connectGamepadButton">Connect Gamepad</button>
                    <div id="gamepadInfo" class="gamepad-status">
                        Not connected
                    </div>
                    <div
                        id="gamepadDebug"
                        class="gamepad-status"
                        style="font-size: 0.85em; color: #b0b0b0"
                    ></div>
                </div>
            </section>
        </div>

        <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
        <script>
            // DOM Elements
            const motorStatusEl = document.getElementById("motorStatus");
            const gamepadInfoEl = document.getElementById("gamepadInfo");
            const gamepadDebugEl = document.getElementById("gamepadDebug");
            const speedSlider = document.getElementById("speedSlider");
            const speedValueEl = document.getElementById("speedValue");
            const cameraSpeedSlider =
                document.getElementById("cameraSpeedSlider");
            const cameraSpeedValueEl =
                document.getElementById("cameraSpeedValue");
            const connectGamepadButton = document.getElementById(
                "connectGamepadButton",
            );

            // State
            let socket = null;
            let wsConnected = false;
            let currentSpeed = 50;
            let currentCameraSpeed = 5;
            const keyState = { w: false, a: false, s: false, d: false };
            let activeGamepad = null;
            let lastSentCmd = { a: 0, b: 0 };
            let cameraControlActive = false;
            let cameraControlInterval = null;
            let lastCameraTime = 0;

            // Timing constants
            const MOTOR_INTERVAL = 30; // ms (~33Hz)
            const CAMERA_INTERVAL = 50; // ms (20Hz)

            // Socket.IO Setup
            socket = io({
                transports: ["websocket", "polling"],
                upgrade: true,
                rememberUpgrade: true,
                timeout: 5000,
                reconnection: true,
                reconnectionDelay: 500,
                reconnectionAttempts: 10,
            });

            socket.on("connect", () => {
                wsConnected = true;
                motorStatusEl.textContent = "Connected";
                motorStatusEl.className = "status-connected";
            });

            socket.on("disconnect", () => {
                wsConnected = false;
                motorStatusEl.textContent = "Disconnected";
                motorStatusEl.className = "status-disconnected";
            });

            socket.on("motor_status", (data) => {
                if (data && data.state) {
                    motorStatusEl.textContent = data.state;
                }
            });

            // Motor Control
            function sendMotorCommand(a, b) {
                if (!wsConnected) return;

                const finalA = Math.round(
                    Math.max(-100, Math.min(100, a)) * (currentSpeed / 100),
                );
                const finalB = Math.round(
                    Math.max(-100, Math.min(100, b)) * (currentSpeed / 100),
                );

                if (finalA === lastSentCmd.a && finalB === lastSentCmd.b)
                    return;

                lastSentCmd = { a: finalA, b: finalB };
                socket.emit("motor_command", { a: finalA, b: finalB });
            }

            function sendStopCommand() {
                if (!wsConnected) return;
                lastSentCmd = { a: 0, b: 0 };
                socket.emit("stop_command");
            }

            // Camera Control
            function sendCameraCommand(pan, tilt, absolute = false) {
                if (!wsConnected) return;
                const now = Date.now();
                if (now - lastCameraTime < CAMERA_INTERVAL) return;

                lastCameraTime = now;
                const cmd = {
                    pan,
                    tilt,
                    speed: currentCameraSpeed,
                };
                if (absolute) {
                    cmd.absolute = true;
                }
                socket.emit("camera_command", cmd);
            }

            function startCameraControl(direction) {
                if (cameraControlInterval) stopCameraControl();

                cameraControlActive = true;
                const STEP = 1.0;
                const dirs = {
                    up: { pan: 0, tilt: STEP },
                    down: { pan: 0, tilt: -STEP },
                    left: { pan: -STEP, tilt: 0 },
                    right: { pan: STEP, tilt: 0 },
                };

                const step = dirs[direction];
                if (!step) return;

                sendCameraCommand(step.pan, step.tilt);
                cameraControlInterval = setInterval(() => {
                    if (cameraControlActive) {
                        sendCameraCommand(step.pan, step.tilt);
                    }
                }, CAMERA_INTERVAL);
            }

            function stopCameraControl() {
                cameraControlActive = false;
                if (cameraControlInterval) {
                    clearInterval(cameraControlInterval);
                    cameraControlInterval = null;
                }
            }

            // Movement Handler
            function calculateMotorValues() {
                let y = 0,
                    x = 0;

                if (keyState.w) y = 100;
                else if (keyState.s) y = -100;
                if (keyState.a) x = -100;
                else if (keyState.d) x = 100;

                if (y === 0 && x === 0) return { a: 0, b: 0 };

                let motorA, motorB;
                if (y !== 0) {
                    motorA = y;
                    motorB = y;
                    if (x < 0) motorA = y * 0.6;
                    else if (x > 0) motorB = y * 0.6;
                } else {
                    motorA = x;
                    motorB = -x;
                }

                return { a: motorA, b: motorB };
            }

            function updateMotors() {
                const motors = calculateMotorValues();
                if (motors.a === 0 && motors.b === 0) {
                    sendStopCommand();
                } else {
                    sendMotorCommand(motors.a, motors.b);
                }
            }

            // Keyboard Events
            document.addEventListener("keydown", (e) => {
                const key = e.key.toLowerCase();

                // Arrow keys for camera control
                if (
                    key === "arrowup" ||
                    key === "arrowdown" ||
                    key === "arrowleft" ||
                    key === "arrowright"
                ) {
                    e.preventDefault();
                    const dirMap = {
                        arrowup: "up",
                        arrowdown: "down",
                        arrowleft: "left",
                        arrowright: "right",
                    };
                    startCameraControl(dirMap[key]);
                } else if (keyState.hasOwnProperty(key) && !keyState[key]) {
                    keyState[key] = true;
                    updateMotors();
                } else if (key === " ") {
                    e.preventDefault();
                    sendStopCommand();
                }
            });

            document.addEventListener("keyup", (e) => {
                const key = e.key.toLowerCase();

                // Stop camera control on arrow key release
                if (
                    key === "arrowup" ||
                    key === "arrowdown" ||
                    key === "arrowleft" ||
                    key === "arrowright"
                ) {
                    e.preventDefault();
                    stopCameraControl();
                } else if (keyState.hasOwnProperty(key)) {
                    keyState[key] = false;
                    updateMotors();
                }
            });

            // Button Events
            document
                .querySelectorAll(".buttons-grid button")
                .forEach((button) => {
                    const key = button.dataset.key;
                    const direction = button.dataset.direction;

                    const press = (e) => {
                        e.preventDefault();
                        if (key === "stop") {
                            sendStopCommand();
                        } else if (direction === "center") {
                            if (wsConnected) {
                                stopCameraControl();
                                socket.emit("camera_command", { center: true });
                            }
                        } else if (direction) {
                            startCameraControl(direction);
                        } else if (keyState.hasOwnProperty(key)) {
                            keyState[key] = true;
                            updateMotors();
                        }
                    };

                    const release = (e) => {
                        e.preventDefault();
                        if (direction && direction !== "center") {
                            stopCameraControl();
                        } else if (
                            key !== "stop" &&
                            keyState.hasOwnProperty(key)
                        ) {
                            keyState[key] = false;
                            updateMotors();
                        }
                    };

                    button.addEventListener("mousedown", press);
                    button.addEventListener("mouseup", release);
                    button.addEventListener("mouseleave", release);
                    button.addEventListener("touchstart", press, {
                        passive: false,
                    });
                    button.addEventListener("touchend", release, {
                        passive: false,
                    });
                });

            // Speed Controls
            speedSlider.addEventListener("input", () => {
                currentSpeed = parseInt(speedSlider.value);
                speedValueEl.textContent = currentSpeed;
                if (Object.values(keyState).some((s) => s)) updateMotors();
            });

            cameraSpeedSlider.addEventListener("input", () => {
                currentCameraSpeed = parseFloat(cameraSpeedSlider.value);
                cameraSpeedValueEl.textContent = currentCameraSpeed;
            });

            // Gamepad Support
            let lastGamepadActive = false;
            let l3Pressed = false;
            let r3Pressed = false;

            connectGamepadButton.addEventListener("click", async () => {
                if (!navigator.hid) {
                    gamepadInfoEl.innerHTML =
                        "WebHID not supported.<br>Use Chrome/Edge/Opera.";
                    return;
                }
                try {
                    await navigator.hid.requestDevice({ filters: [] });
                    gamepadInfoEl.textContent =
                        "HID access granted. Checking gamepads...";
                    scanGamepads();
                } catch (error) {
                    gamepadInfoEl.textContent = "HID permission denied.";
                }
            });

            function scanGamepads() {
                const gamepads = navigator.getGamepads();
                for (const gp of gamepads) {
                    if (gp) {
                        handleGamepadConnected(gp);
                        return;
                    }
                }
            }

            function handleGamepadConnected(gp) {
                activeGamepad = gp;
                gamepadInfoEl.textContent = `Gamepad: ${gp.id.substring(0, 25)}...`;
                connectGamepadButton.style.display = "none";
                requestAnimationFrame(gamepadLoop);
            }

            function handleGamepadDisconnected(event) {
                if (
                    activeGamepad &&
                    activeGamepad.index === event.gamepad.index
                ) {
                    activeGamepad = null;
                    gamepadInfoEl.textContent = "Gamepad disconnected.";
                    connectGamepadButton.style.display = "block";
                    sendStopCommand();
                }
            }

            window.addEventListener("gamepadconnected", (e) =>
                handleGamepadConnected(e.gamepad),
            );
            window.addEventListener(
                "gamepaddisconnected",
                handleGamepadDisconnected,
            );

            function pollGamepadInput() {
                if (!activeGamepad) return false;

                const gamepads = navigator.getGamepads();
                if (!gamepads || !gamepads.length) {
                    activeGamepad = null;
                    return false;
                }

                const gp = gamepads[activeGamepad.index];
                if (!gp) {
                    for (let i = 0; i < gamepads.length; i++) {
                        if (gamepads[i]) {
                            activeGamepad = gamepads[i];
                            return pollGamepadInput();
                        }
                    }
                    return false;
                }

                const leftX = gp.axes[0] || 0;
                const leftY = gp.axes[1] || 0;
                const rightX = gp.axes[2] || 0;
                const rightY = gp.axes[3] || 0;
                const l2 = gp.buttons[6] ? gp.buttons[6].value : 0;
                const r2 = gp.buttons[7] ? gp.buttons[7].value : 0;
                const dpadUp = gp.buttons[12] ? gp.buttons[12].pressed : false;
                const dpadDown = gp.buttons[13]
                    ? gp.buttons[13].pressed
                    : false;
                const dpadLeft = gp.buttons[14]
                    ? gp.buttons[14].pressed
                    : false;
                const dpadRight = gp.buttons[15]
                    ? gp.buttons[15].pressed
                    : false;
                const l3 = gp.buttons[10] ? gp.buttons[10].pressed : false;
                const r3 = gp.buttons[11] ? gp.buttons[11].pressed : false;

                // L3 = Stop
                if (l3 && !l3Pressed) {
                    l3Pressed = true;
                    sendStopCommand();
                } else if (!l3) {
                    l3Pressed = false;
                }

                // R3 = Center camera
                if (r3 && !r3Pressed && wsConnected) {
                    r3Pressed = true;
                    socket.emit("camera_command", { center: true });
                } else if (!r3) {
                    r3Pressed = false;
                }

                const deadzone = 0.2;
                let yInput = Math.abs(leftY) > deadzone ? leftY * 100 : 0;
                let xInput = Math.abs(leftX) > deadzone ? leftX : 0;

                if (dpadUp) yInput = -100;
                else if (dpadDown) yInput = 100;
                if (dpadLeft) xInput = -1;
                else if (dpadRight) xInput = 1;

                let steering = 0;
                if (l2 > 0.1) steering = -l2;
                else if (r2 > 0.1) steering = r2;
                if (Math.abs(steering) > 0.1) xInput = steering;

                // Camera with right stick (absolute positioning)
                const camDeadzone = 0.2;
                let pan = Math.abs(rightX) > camDeadzone ? rightX : 0;
                let tilt = Math.abs(rightY) > camDeadzone ? -rightY : 0;

                // Always send camera command with absolute positioning
                // When centered (0,0), camera returns to default position
                if (wsConnected) {
                    sendCameraCommand(pan, tilt, true);
                }

                // Motor control
                if (yInput === 0 && xInput === 0) {
                    if (
                        lastGamepadActive &&
                        !Object.values(keyState).some((s) => s)
                    ) {
                        sendStopCommand();
                    }
                    lastGamepadActive = false;
                    return pan !== 0 || tilt !== 0;
                }

                lastGamepadActive = true;
                let motorA, motorB;

                if (yInput !== 0) {
                    const speed = -yInput;
                    const leftScale = xInput < 0 ? 1 - Math.abs(xInput) : 1;
                    const rightScale = xInput > 0 ? 1 - Math.abs(xInput) : 1;
                    motorA = speed * leftScale;
                    motorB = speed * rightScale;
                } else {
                    motorA = xInput * 100;
                    motorB = -xInput * 100;
                }

                sendMotorCommand(motorA, motorB);

                gamepadDebugEl.textContent = `LX:${leftX.toFixed(2)} LY:${leftY.toFixed(2)} | Motors: ${lastSentCmd.a} ${lastSentCmd.b}`;
                return true;
            }

            function gamepadLoop() {
                if (!activeGamepad) {
                    const gamepads = navigator.getGamepads();
                    if (gamepads && gamepads.length > 0) {
                        for (let i = 0; i < gamepads.length; i++) {
                            if (gamepads[i]) {
                                handleGamepadConnected(gamepads[i]);
                                break;
                            }
                        }
                    }
                    return;
                }

                pollGamepadInput();
                requestAnimationFrame(gamepadLoop);
            }

            // Initialize
            scanGamepads();
        </script>
    </body>
</html>
