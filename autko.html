<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RC Car Control</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #1a1a1a;
            color: #e0e0e0;
            font-family: Arial, sans-serif;
            padding: 15px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #007bff;
        }
        .panel {
            background: #2c2c2c;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .panel h2 {
            margin-bottom: 15px;
            font-size: 1.2em;
            border-bottom: 2px solid #444;
            padding-bottom: 8px;
        }
        .video-feed {
            width: 100%;
            max-height: 480px;
            background: #000;
            border-radius: 6px;
        }
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 15px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 60px;
        }
        button:hover {
            background: #0056b3;
        }
        button:active {
            transform: scale(0.95);
        }
        .stop-btn {
            background: #dc3545;
        }
        .stop-btn:hover {
            background: #c82333;
        }
        .center-btn {
            background: #28a745;
        }
        .center-btn:hover {
            background: #218838;
        }
        .camera-btn {
            background: #28a745;
        }
        .camera-btn:hover {
            background: #218838;
        }
        .status {
            background: #3f3f3f;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            margin-bottom: 10px;
        }
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .speed-control input {
            flex: 1;
        }
        .gamepad-btn {
            width: 100%;
            background: #28a745;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>RC Car Control</h1>
        
        <div class="panel">
            <h2>Camera Feed</h2>
            <img id="cameraFeed" class="video-feed" src="/mjpeg" alt="Camera Feed">
        </div>

        <div class="panel">
            <h2>Camera Control</h2>
            <div class="controls-grid">
                <div></div>
                <button class="camera-btn" data-cam="up">↑</button>
                <div></div>
                <button class="camera-btn" data-cam="left">←</button>
                <button class="center-btn" data-cam="center">⌂</button>
                <button class="camera-btn" data-cam="right">→</button>
                <div></div>
                <button class="camera-btn" data-cam="down">↓</button>
                <div></div>
            </div>
        </div>

        <div class="panel">
            <h2>Movement</h2>
            <div class="controls-grid">
                <div></div>
                <button data-key="w">W</button>
                <div></div>
                <button data-key="a">A</button>
                <button class="stop-btn" data-key="stop">STOP</button>
                <button data-key="d">D</button>
                <div></div>
                <button data-key="s">S</button>
                <div></div>
            </div>
        </div>

        <div class="panel">
            <h2>Speed</h2>
            <div class="speed-control">
                <input type="range" id="speedSlider" min="0" max="100" value="50">
                <span id="speedValue">50%</span>
            </div>
        </div>

        <div class="panel">
            <h2>Status</h2>
            <div id="status" class="status">Ready</div>
        </div>

        <div class="panel">
            <h2>Gamepad</h2>
            <button id="gamepadBtn" class="gamepad-btn">Connect Gamepad</button>
            <div id="gamepadStatus" class="status">Not connected</div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
        const statusEl = document.getElementById('status');
        const gamepadStatusEl = document.getElementById('gamepadStatus');
        const speedSlider = document.getElementById('speedSlider');
        const speedValueEl = document.getElementById('speedValue');
        const gamepadBtn = document.getElementById('gamepadBtn');

        let currentSpeed = parseInt(speedSlider.value);
        const keyState = { w: false, a: false, s: false, d: false };
        let activeGamepad = null;
        let lastSentCmd = { a: null, b: null };
        let wsConnected = false;
        let socket = null;
        let cameraControlActive = false;
        let cameraControlInterval = null;
        let lastCameraCommandTime = 0;
        const CAMERA_COMMAND_INTERVAL = 100;

        function setupSocket() {
            socket = io();
            socket.on('connect', () => {
                wsConnected = true;
                statusEl.textContent = 'Connected';
            });
            socket.on('disconnect', () => {
                wsConnected = false;
                statusEl.textContent = 'Disconnected';
            });
            socket.on('motor_status', (data) => {
                if (data && data.state) {
                    statusEl.textContent = data.state;
                }
            });
        }
        setupSocket();

        function sendMotorCommand(a, b) {
            if (!wsConnected) return;
            const finalA = Math.round(Math.max(-100, Math.min(100, a)) * (currentSpeed / 100));
            const finalB = Math.round(Math.max(-100, Math.min(100, b)) * (currentSpeed / 100));
            if (finalA === lastSentCmd.a && finalB === lastSentCmd.b) return;
            lastSentCmd = { a: finalA, b: finalB };
            socket.emit('motor_command', { a: finalA, b: finalB });
        }

        function sendStopCommand() {
            if (!wsConnected) return;
            lastSentCmd = { a: 0, b: 0 };
            socket.emit('stop_command');
        }

        function sendCameraCommand(pan, tilt) {
            if (!wsConnected) return;
            const now = Date.now();
            if ((now - lastCameraCommandTime) >= CAMERA_COMMAND_INTERVAL) {
                socket.emit('camera_command', { pan: pan, tilt: tilt });
                lastCameraCommandTime = now;
            }
        }

        function startCameraControl(direction) {
            if (cameraControlActive && cameraControlInterval) {
                stopCameraControl();
            }
            cameraControlActive = true;
            const CAMERA_STEP = 1.0;
            
            const directions = {
                'up': { pan: 0, tilt: CAMERA_STEP },
                'down': { pan: 0, tilt: -CAMERA_STEP },
                'left': { pan: -CAMERA_STEP, tilt: 0 },
                'right': { pan: CAMERA_STEP, tilt: 0 }
            };
            
            const step = directions[direction];
            if (!step) return;
            
            sendCameraCommand(step.pan, step.tilt);
            
            cameraControlInterval = setInterval(() => {
                if (cameraControlActive) {
                    sendCameraCommand(step.pan, step.tilt);
                }
            }, CAMERA_COMMAND_INTERVAL);
        }

        function stopCameraControl() {
            cameraControlActive = false;
            if (cameraControlInterval) {
                clearInterval(cameraControlInterval);
                cameraControlInterval = null;
            }
        }

        function handleMovement() {
            if (activeGamepad && pollGamepadInput()) {
                return;
            }
            let y = 0;
            let x = 0;
            if (keyState.w) y = 100;
            else if (keyState.s) y = -100;
            if (keyState.a) x = -100;
            else if (keyState.d) x = 100;
            if (y === 0 && x === 0) {
                sendStopCommand();
                return;
            }
            let motorA, motorB;
            if (y !== 0) {
                motorA = y;
                motorB = y;
                if (x < 0) {
                    motorA = y * 0.3;
                } else if (x > 0) {
                    motorB = y * 0.3;
                }
            } else {
                motorA = x;
                motorB = -x;
            }
            sendMotorCommand(motorA, motorB);
        }

        speedSlider.addEventListener('input', () => {
            currentSpeed = parseInt(speedSlider.value);
            speedValueEl.textContent = `${currentSpeed}%`;
            if (Object.values(keyState).some(s => s) || activeGamepad) {
                handleMovement();
            }
        });

        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (keyState.hasOwnProperty(key) && !keyState[key]) {
                keyState[key] = true;
                handleMovement();
            } else if (key === ' ') {
                e.preventDefault();
                sendStopCommand();
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keyState.hasOwnProperty(key)) {
                keyState[key] = false;
                handleMovement();
            }
        });

        document.querySelectorAll('button[data-key]').forEach(button => {
            const key = button.dataset.key;
            
            function pressButton(e) {
                e.preventDefault();
                if (key === 'stop') {
                    sendStopCommand();
                } else if (keyState.hasOwnProperty(key)) {
                    keyState[key] = true;
                    handleMovement();
                }
            }
            
            function releaseButton(e) {
                e.preventDefault();
                if (key !== 'stop' && keyState.hasOwnProperty(key)) {
                    keyState[key] = false;
                    handleMovement();
                }
            }
            
            button.addEventListener('mousedown', pressButton);
            button.addEventListener('mouseup', releaseButton);
            button.addEventListener('mouseleave', releaseButton);
            button.addEventListener('touchstart', pressButton, { passive: false });
            button.addEventListener('touchend', releaseButton, { passive: false });
        });

        document.querySelectorAll('button[data-cam]').forEach(button => {
            const direction = button.dataset.cam;
            
            function pressButton(e) {
                e.preventDefault();
                if (direction === 'center') {
                    if (wsConnected) {
                        stopCameraControl();
                        socket.emit('camera_command', { center: true });
                    }
                } else {
                    startCameraControl(direction);
                }
            }
            
            function releaseButton(e) {
                e.preventDefault();
                if (direction !== 'center') {
                    stopCameraControl();
                }
            }
            
            button.addEventListener('mousedown', pressButton);
            button.addEventListener('mouseup', releaseButton);
            button.addEventListener('mouseleave', releaseButton);
            button.addEventListener('touchstart', pressButton, { passive: false });
            button.addEventListener('touchend', releaseButton, { passive: false });
        });

        gamepadBtn.addEventListener('click', async () => {
            if (!navigator.hid) {
                gamepadStatusEl.textContent = "WebHID not supported";
                return;
            }
            try {
                await navigator.hid.requestDevice({ filters: [] });
                scanGamepads();
            } catch (error) {
                console.error("HID permission error:", error);
            }
        });

        function scanGamepads() {
            const gamepads = navigator.getGamepads();
            for (const gp of gamepads) {
                if (gp) {
                    handleGamepadConnected(gp);
                    return;
                }
            }
        }

        function handleGamepadConnected(gp) {
            activeGamepad = gp;
            gamepadStatusEl.textContent = `Connected: ${gp.id.substring(0,30)}`;
            gamepadBtn.style.display = 'none';
            requestAnimationFrame(gamepadLoop);
        }

        function handleGamepadDisconnected(event) {
            if (activeGamepad && activeGamepad.index === event.gamepad.index) {
                activeGamepad = null;
                gamepadStatusEl.textContent = "Disconnected";
                gamepadBtn.style.display = 'block';
                sendStopCommand();
            }
        }

        window.addEventListener("gamepadconnected", (e) => handleGamepadConnected(e.gamepad));
        window.addEventListener("gamepaddisconnected", handleGamepadDisconnected);

        function pollGamepadInput() {
            if (!activeGamepad) return false;
            const gamepads = navigator.getGamepads();
            if (!gamepads || gamepads.length === 0) {
                activeGamepad = null;
                return false;
            }
            const gp = gamepads[activeGamepad.index];
            if (!gp) {
                for (let i = 0; i < gamepads.length; i++) {
                    if (gamepads[i]) {
                        activeGamepad = gamepads[i];
                        break;
                    }
                }
                if (!activeGamepad) {
                    return false;
                }
                return pollGamepadInput();
            }

            const leftStickX = gp.axes[0] || 0;
            const leftStickY = gp.axes[1] || 0;
            const rightStickX = gp.axes[2] || 0;
            const rightStickY = gp.axes[3] || 0;
            
            const l2Button = gp.buttons[6] ? gp.buttons[6].value : 0;
            const r2Button = gp.buttons[7] ? gp.buttons[7].value : 0;
            
            const dpadUp = gp.buttons[12] ? gp.buttons[12].pressed : false;
            const dpadDown = gp.buttons[13] ? gp.buttons[13].pressed : false;
            const dpadLeft = gp.buttons[14] ? gp.buttons[14].pressed : false;
            const dpadRight = gp.buttons[15] ? gp.buttons[15].pressed : false;
            
            const deadzone = 0.20;
            let yInput = Math.abs(leftStickY) > deadzone ? leftStickY * 100 : 0;
            let xInput = Math.abs(leftStickX) > deadzone ? leftStickX : 0;
            
            if (dpadUp) yInput = -100;
            else if (dpadDown) yInput = 100;
            if (dpadLeft) xInput = -1;
            else if (dpadRight) xInput = 1;
            
            let steeringInput = 0;
            if (l2Button > 0.1) {
                steeringInput = -l2Button;
            } else if (r2Button > 0.1) {
                steeringInput = r2Button;
            }
            
            if (Math.abs(steeringInput) > 0.1) {
                xInput = steeringInput;
            }
            
            let actualRightStickX = rightStickX;
            let actualRightStickY = rightStickY;
            
            if (gp.axes.length > 4 && (Math.abs(rightStickX) < 0.01 && Math.abs(rightStickY) < 0.01)) {
                actualRightStickX = gp.axes[4] || 0;
                actualRightStickY = gp.axes[5] || 0;
            }
            
            const cameraDeadzone = 0.15;
            let panDelta = 0;
            let tiltDelta = 0;
            
            if (Math.abs(actualRightStickX) > cameraDeadzone) {
                panDelta = actualRightStickX;
            }
            if (Math.abs(actualRightStickY) > cameraDeadzone) {
                tiltDelta = -actualRightStickY;
            }
            
            const now = Date.now();
            if ((panDelta !== 0 || tiltDelta !== 0) && (now - lastCameraCommandTime) >= CAMERA_COMMAND_INTERVAL) {
                if (wsConnected) {
                    socket.emit('camera_command', { pan: panDelta, tilt: tiltDelta });
                    lastCameraCommandTime = now;
                }
            }
            
            if (yInput === 0 && xInput === 0) {
                return (panDelta !== 0 || tiltDelta !== 0);
            }

            let motorA_gp, motorB_gp;
            if (yInput !== 0) {
                const speed = -yInput;
                const leftScale = xInput < 0 ? 1 - Math.abs(xInput) : 1;
                const rightScale = xInput > 0 ? 1 - Math.abs(xInput) : 1;
                motorA_gp = speed * leftScale;
                motorB_gp = speed * rightScale;
            } else {
                motorA_gp = xInput * 100;
                motorB_gp = -xInput * 100;
            }
            sendMotorCommand(motorA_gp, motorB_gp);
            return true;
        }

        function gamepadLoop() {
            if (!activeGamepad) {
                const gamepads = navigator.getGamepads();
                if (gamepads && gamepads.length > 0) {
                    for (let i = 0; i < gamepads.length; i++) {
                        if (gamepads[i]) {
                            handleGamepadConnected(gamepads[i]);
                            break;
                        }
                    }
                }
                return;
            }
            try {
                pollGamepadInput();
            } catch (error) {
                console.error('Gamepad error:', error);
            }
            requestAnimationFrame(gamepadLoop);
        }

        scanGamepads();
    </script>
</body>
</html>
