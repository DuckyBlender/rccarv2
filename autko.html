<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPi Car Control</title>
    <style>
        :root {
            --primary-bg: #1a1a1a;
            --secondary-bg: #2c2c2c;
            --tertiary-bg: #3f3f3f;
            --primary-text: #e0e0e0;
            --accent-color: #007bff;
            --accent-hover: #0056b3;
            --danger-color: #dc3545;
            --danger-hover: #c82333;
            --success-color: #28a745;
            --success-hover: #218838;
            --border-color: #4a4a4a;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--primary-bg);
            color: var(--primary-text);
            font-family: var(--font-family);
            margin: 0;
            padding: 15px;
            box-sizing: border-box;
        }


        .main-container {
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
        }

        .panel {
            background-color: var(--secondary-bg);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .controls-section {
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
        }
        
        .control-group {
            background-color: var(--tertiary-bg);
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 10px;
        }

        .control-group h3 {
            margin: 0 0 10px 0;
            color: var(--primary-text);
            font-size: 1em;
            font-weight: 500;
        }

        .buttons-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, auto);
            gap: 8px;
            align-items: center;
            justify-items: center;
        }

        .buttons-grid button {
            width: 100%;
            min-height: 50px;
            font-size: 1.1em;
            font-weight: bold;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .buttons-grid button:hover {
            background-color: var(--accent-hover);
        }
        .buttons-grid button:active {
            transform: scale(0.95);
        }

        .buttons-grid .stop-button {
            grid-column: 2;
            grid-row: 2;
            background-color: var(--danger-color);
        }
        .buttons-grid .stop-button:hover {
            background-color: var(--danger-hover);
        }
        .buttons-grid .button-w { grid-column: 2; grid-row: 1; }
        .buttons-grid .button-a { grid-column: 1; grid-row: 2; }
        .buttons-grid .button-s { grid-column: 2; grid-row: 3; }
        .buttons-grid .button-d { grid-column: 3; grid-row: 2; }
        
        .buttons-grid .camera-button {
            font-size: 1.8em;
            background-color: var(--success-color);
        }
        .buttons-grid .camera-button:hover {
            background-color: var(--success-hover);
        }
        .buttons-grid #camera-up { grid-column: 2; grid-row: 1; }
        .buttons-grid #camera-left { grid-column: 1; grid-row: 2; }
        .buttons-grid #camera-center { grid-column: 2; grid-row: 2; background-color: var(--accent-color); }
        .buttons-grid #camera-center:hover { background-color: var(--accent-hover); }
        .buttons-grid #camera-right { grid-column: 3; grid-row: 2; }
        .buttons-grid #camera-down { grid-column: 2; grid-row: 3; }

        #speedSlider {
            accent-color: var(--accent-color);
        }

        .gamepad-status {
            font-size: 0.9em;
            padding: 8px;
            text-align: center;
            word-break: break-word;
        }

        #connectGamepadButton {
            width: 100%;
            padding: 12px;
            font-size: 1.1em;
            font-weight: 500;
            background-color: var(--success-color);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-top: 10px;
        }
        #connectGamepadButton:hover {
            background-color: var(--success-hover);
        }


    </style>
</head>
<body>
    <div class="main-container">
        <section class="panel controls-section">
            <div class="control-group">
                <h3>Camera Control</h3>
                <div class="buttons-grid">
                    <button class="camera-button" id="camera-up" data-direction="up">↑</button>
                    <button class="camera-button" id="camera-left" data-direction="left">←</button>
                    <button class="camera-button" id="camera-center" data-direction="center">⌂</button>
                    <button class="camera-button" id="camera-right" data-direction="right">→</button>
                    <button class="camera-button" id="camera-down" data-direction="down">↓</button>
                </div>
            </div>

            <div class="control-group">
                <h3>Movement</h3>
                <div class="buttons-grid">
                    <button class="button-w" data-key="w">W</button>
                    <button class="button-a" data-key="a">A</button>
                    <button class="stop-button" data-key="stop">STOP</button>
                    <button class="button-s" data-key="s">S</button>
                    <button class="button-d" data-key="d">D</button>
                </div>
            </div>

            <div class="control-group">
                <h3>Speed: <span id="speedValue">50%</span> | Status: <span id="motorStatus">Ready</span></h3>
                <input type="range" id="speedSlider" min="0" max="100" value="50" style="width: 100%;">
            </div>

            <div class="control-group">
                <button id="connectGamepadButton">Connect Gamepad</button>
                <div id="gamepadInfo" class="gamepad-status" style="margin-top: 10px;">Not connected</div>
            </div>
        </section>
    </div>


    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
        const motorStatusEl = document.getElementById('motorStatus');
        const gamepadInfoEl = document.getElementById('gamepadInfo');
        const speedSlider = document.getElementById('speedSlider');
        const speedValueEl = document.getElementById('speedValue');
        const connectGamepadButton = document.getElementById('connectGamepadButton');

        let currentSpeed = parseInt(speedSlider.value);
        const keyState = { w: false, a: false, s: false, d: false };
        let activeGamepad = null;
        let lastMotorCmd = { a: 0, b: 0 };
        let lastSentCmd = { a: null, b: null };
        let wsConnected = false;
        let socket = null;
        const COMMAND_DEBOUNCE_INTERVAL = 75; // ms
        let lastCameraCommandTime = 0;
        const CAMERA_COMMAND_INTERVAL = 100; // ms - throttle camera commands to prevent over-correction
        let cameraControlActive = false;
        let cameraControlInterval = null;

        function sendCameraCommand(pan, tilt) {
            if (!wsConnected) return;
            const now = Date.now();
            if ((now - lastCameraCommandTime) >= CAMERA_COMMAND_INTERVAL) {
                socket.emit('camera_command', { pan: pan, tilt: tilt });
                lastCameraCommandTime = now;
            }
        }

        function startCameraControl(direction) {
            if (cameraControlActive && cameraControlInterval) {
                // If already active with different direction, stop first
                stopCameraControl();
            }
            cameraControlActive = true;
            const CAMERA_STEP = 1.0; // Step value for button control
            
            const directions = {
                'up': { pan: 0, tilt: CAMERA_STEP },
                'down': { pan: 0, tilt: -CAMERA_STEP },
                'left': { pan: -CAMERA_STEP, tilt: 0 },
                'right': { pan: CAMERA_STEP, tilt: 0 }
            };
            
            const step = directions[direction];
            if (!step) {
                console.log('Invalid camera direction:', direction);
                return;
            }
            
            // Send immediate command
            sendCameraCommand(step.pan, step.tilt);
            
            // Then set up interval for continuous movement
            cameraControlInterval = setInterval(() => {
                if (cameraControlActive) {
                    sendCameraCommand(step.pan, step.tilt);
                }
            }, CAMERA_COMMAND_INTERVAL);
        }

        function stopCameraControl() {
            cameraControlActive = false;
            if (cameraControlInterval) {
                clearInterval(cameraControlInterval);
                cameraControlInterval = null;
            }
        }

        function setupSocket() {
            socket = io();
            socket.on('connect', () => {
                wsConnected = true;
                motorStatusEl.textContent = 'WebSocket connected';
            });
            socket.on('disconnect', () => {
                wsConnected = false;
                motorStatusEl.textContent = 'WebSocket disconnected';
            });
            socket.on('motor_status', (data) => {
                if (data && data.state) {
                    motorStatusEl.textContent = `Status: ${data.state} | Speed Setting: ${data.speed}`;
                }
            });
        }
        setupSocket();

        function sendMotorCommandWS(targetMotorA, targetMotorB) {
            if (!wsConnected) return;
            // Scale raw motor values (-100 to 100) by currentSpeed
            const finalA = Math.round(Math.max(-100, Math.min(100, targetMotorA)) * (currentSpeed / 100));
            const finalB = Math.round(Math.max(-100, Math.min(100, targetMotorB)) * (currentSpeed / 100));
            // Debounce: Only send if values changed
            if (finalA === lastSentCmd.a && finalB === lastSentCmd.b) return;
            lastSentCmd = { a: finalA, b: finalB };
            socket.emit('motor_command', { a: finalA, b: finalB });
        }
        function sendStopCommandWS() {
            if (!wsConnected) return;
            lastSentCmd = { a: 0, b: 0 };
            socket.emit('stop_command');
        }

        function updateSpeedDisplay() {
            currentSpeed = parseInt(speedSlider.value);
            speedValueEl.textContent = `${currentSpeed}%`;
            // If a movement command is active (e.g. key held or joystick moved), resend with new speed
            if (Object.values(keyState).some(s => s) || activeGamepad) {
                handleMovement();
            }
        }
        speedSlider.addEventListener('input', updateSpeedDisplay);
        updateSpeedDisplay();

        function handleMovement() {
            // Prioritize gamepad if active and providing input
            if (activeGamepad && pollGamepadInput()) {
                return;
            }
            // Keyboard movement
            let y = 0;
            let x = 0;
            if (keyState.w) y = 100;
            else if (keyState.s) y = -100;
            if (keyState.a) x = -100;
            else if (keyState.d) x = 100;
            if (y === 0 && x === 0) {
                sendStopCommandWS();
                return;
            }
            let motorA, motorB;
            if (y !== 0) {
                motorA = y;
                motorB = y;
                if (x < 0) {
                    motorA = y * 0.3;
                } else if (x > 0) {
                    motorB = y * 0.3;
                }
            } else {
                motorA = x;
                motorB = -x;
            }
            sendMotorCommandWS(motorA, motorB);
        }

        // --- Keyboard Event Listeners ---
        document.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();
            if (keyState.hasOwnProperty(key) && !keyState[key]) {
                keyState[key] = true;
                handleMovement();
            } else if (key === ' ') {
                event.preventDefault();
                sendStopCommandWS();
            }
        });
        document.addEventListener('keyup', (event) => {
            const key = event.key.toLowerCase();
            if (keyState.hasOwnProperty(key)) {
                keyState[key] = false;
                if (!Object.values(keyState).some(s => s) && !activeGamepad) {
                    handleMovement();
                } else {
                    handleMovement();
                }
            }
        });
        // --- On-Screen Button Listeners ---
        document.querySelectorAll('.buttons-grid button').forEach(button => {
            const key = button.dataset.key;
            const direction = button.dataset.direction;
            
            function pressButton(e) {
                e.preventDefault();
                e.stopPropagation();
                if (key === 'stop') {
                    sendStopCommandWS();
                } else if (direction === 'center') {
                    // Center camera servos
                    if (wsConnected) {
                        stopCameraControl();
                        socket.emit('camera_command', { center: true });
                    }
                } else if (direction) {
                    // Camera control
                    startCameraControl(direction);
                } else if (keyState.hasOwnProperty(key)) {
                    keyState[key] = true;
                    handleMovement();
                }
            }
            function releaseButton(e) {
                e.preventDefault();
                e.stopPropagation();
                if (direction && direction !== 'center') {
                    stopCameraControl();
                } else if (key !== 'stop' && keyState.hasOwnProperty(key)) {
                    keyState[key] = false;
                    handleMovement();
                }
            }
            button.addEventListener('mousedown', pressButton);
            button.addEventListener('mouseup', releaseButton);
            button.addEventListener('mouseleave', (e) => {
                if (direction && direction !== 'center') {
                    stopCameraControl();
                } else if (key !== 'stop' && keyState[key]) {
                    releaseButton(e);
                }
            });
            button.addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                pressButton(e); 
            }, { passive: false });
            button.addEventListener('touchend', (e) => { 
                e.preventDefault(); 
                releaseButton(e); 
            }, { passive: false });
        });

        // --- Gamepad Logic ---
        let lastGamepadActive = false;
        connectGamepadButton.addEventListener('click', async () => {
            if (!navigator.hid) {
                gamepadInfoEl.innerHTML = "WebHID API not supported. <br>Please use Chrome, Edge, or Opera.";
                return;
            }
            try {
                const devices = await navigator.hid.requestDevice({ filters: [] });
                if (devices.length > 0) {
                    gamepadInfoEl.textContent = "HID device access granted. Checking for gamepads...";
                } else {
                    gamepadInfoEl.textContent = "No HID device selected. Gamepad may not be accessible.";
                }
                scanGamepads();
            } catch (error) {
                gamepadInfoEl.textContent = "Could not get HID permission. Gamepad may not work.";
                console.error("HID permission error:", error);
            }
        });
        function scanGamepads() {
            const gamepads = navigator.getGamepads();
            for (const gp of gamepads) {
                if (gp) {
                    handleGamepadConnected(gp);
                    return;
                }
            }
        }
        function handleGamepadConnected(gp) {
            activeGamepad = gp;
            gamepadInfoEl.textContent = `Gamepad: ${gp.id.substring(0,25)}...`;
            connectGamepadButton.style.display = 'none';
            requestAnimationFrame(gamepadLoop);
        }
        function handleGamepadDisconnected(event) {
            if (activeGamepad && activeGamepad.index === event.gamepad.index) {
                activeGamepad = null;
                gamepadInfoEl.textContent = "Gamepad disconnected. Reconnect or use keyboard.";
                connectGamepadButton.style.display = 'block';
                sendStopCommandWS();
            }
        }
        window.addEventListener("gamepadconnected", (e) => handleGamepadConnected(e.gamepad));
        window.addEventListener("gamepaddisconnected", handleGamepadDisconnected);
        function pollGamepadInput() {
            if (!activeGamepad) return false;
            const gamepads = navigator.getGamepads();
            if (!gamepads || gamepads.length === 0) {
                activeGamepad = null;
                lastGamepadActive = false;
                return false;
            }
            const gp = gamepads[activeGamepad.index];
            if (!gp) {
                // Try to find any connected gamepad
                for (let i = 0; i < gamepads.length; i++) {
                    if (gamepads[i]) {
                        activeGamepad = gamepads[i];
                        break;
                    }
                }
                if (!activeGamepad) {
                    lastGamepadActive = false;
                    return false;
                }
                return pollGamepadInput(); // Recursive call with new gamepad
            }
            const leftStickX = gp.axes[0] || 0;
            const leftStickY = gp.axes[1] || 0;
            const rightStickX = gp.axes[2] || 0;
            const rightStickY = gp.axes[3] || 0;
            
            // L2 and R2 buttons (usually buttons[6] and buttons[7], or can be analog)
            const l2Button = gp.buttons[6] ? gp.buttons[6].value : 0;
            const r2Button = gp.buttons[7] ? gp.buttons[7].value : 0;
            
            // D-pad buttons (buttons[12-15])
            const dpadUp = gp.buttons[12] ? gp.buttons[12].pressed : false;
            const dpadDown = gp.buttons[13] ? gp.buttons[13].pressed : false;
            const dpadLeft = gp.buttons[14] ? gp.buttons[14].pressed : false;
            const dpadRight = gp.buttons[15] ? gp.buttons[15].pressed : false;
            
            const deadzone = 0.20;
            let yInput = Math.abs(leftStickY) > deadzone ? leftStickY * 100 : 0;
            let xInput = Math.abs(leftStickX) > deadzone ? leftStickX : 0; // xInput in range [-1,1]
            
            // D-pad overrides joystick for movement
            if (dpadUp) yInput = -100;
            else if (dpadDown) yInput = 100;
            if (dpadLeft) xInput = -1;
            else if (dpadRight) xInput = 1;
            
            // Handle L2/R2 steering
            let steeringInput = 0;
            if (l2Button > 0.1) {
                steeringInput = -l2Button; // L2 = steer left
            } else if (r2Button > 0.1) {
                steeringInput = r2Button; // R2 = steer right
            }
            
            // Apply steering to xInput if triggers are pressed
            if (Math.abs(steeringInput) > 0.1) {
                xInput = steeringInput;
            }
            
            // Handle camera movement with right joystick
            // Check all axes to find right stick (some controllers use different indices)
            let actualRightStickX = rightStickX;
            let actualRightStickY = rightStickY;
            
            // If axes 2/3 are undefined or zero, try alternative indices (some controllers use 4/5)
            if (gp.axes.length > 4 && (Math.abs(rightStickX) < 0.01 && Math.abs(rightStickY) < 0.01)) {
                actualRightStickX = gp.axes[4] || 0;
                actualRightStickY = gp.axes[5] || 0;
            }
            
            const cameraDeadzone = 0.20;
            const rightStickXAbs = Math.abs(actualRightStickX);
            const rightStickYAbs = Math.abs(actualRightStickY);
            let panDelta = 0;
            let tiltDelta = 0;
            
            if (rightStickXAbs > cameraDeadzone) {
                panDelta = actualRightStickX;
            }
            if (rightStickYAbs > cameraDeadzone) {
                tiltDelta = -actualRightStickY;
            }
            
            // Send camera commands if joystick is moved (throttled)
            const now = Date.now();
            if ((panDelta !== 0 || tiltDelta !== 0) && (now - lastCameraCommandTime) >= CAMERA_COMMAND_INTERVAL) {
                if (wsConnected) {
                    socket.emit('camera_command', { pan: panDelta, tilt: tiltDelta });
                    lastCameraCommandTime = now;
                }
            }
            
            // Handle motor control
            if (yInput === 0 && xInput === 0) {
                if (lastGamepadActive) {
                    if (!Object.values(keyState).some(s => s)) {
                        sendStopCommandWS();
                    }
                    lastGamepadActive = false;
                }
                // Return true if camera is being controlled, false otherwise
                return (panDelta !== 0 || tiltDelta !== 0);
            }
            lastGamepadActive = true;
            let motorA_gp, motorB_gp;
            if (yInput !== 0) {
                // Linear scaling for tank drive
                // Up = -100, Down = 100, so invert yInput for forward
                const speed = -yInput;
                // xInput in [-1,1], left = -1, right = 1
                const leftScale = xInput < 0 ? 1 - Math.abs(xInput) : 1;
                const rightScale = xInput > 0 ? 1 - Math.abs(xInput) : 1;
                motorA_gp = speed * leftScale;
                motorB_gp = speed * rightScale;
            } else {
                // Pivot in place
                motorA_gp = xInput * 100;
                motorB_gp = -xInput * 100;
            }
            sendMotorCommandWS(motorA_gp, motorB_gp);
            const steeringInfo = steeringInput !== 0 ? ` L2:${l2Button.toFixed(2)} R2:${r2Button.toFixed(2)}` : '';
            const cameraInfo = (panDelta !== 0 || tiltDelta !== 0) ? ` | Camera RX:${actualRightStickX.toFixed(2)} RY:${actualRightStickY.toFixed(2)}` : '';
            const axisInfo = gp.axes.length > 0 ? ` [Axes: ${gp.axes.length}]` : '';
            gamepadInfoEl.textContent = `Gamepad Active | LX:${leftStickX.toFixed(2)} LY:${leftStickY.toFixed(2)}${steeringInfo} | Motors A:${lastSentCmd.a} B:${lastSentCmd.b}${cameraInfo}${axisInfo}`;
            return true;
        }
        function gamepadLoop() {
            if (!activeGamepad) {
                // Check if gamepad got disconnected
                const gamepads = navigator.getGamepads();
                if (gamepads && gamepads.length > 0) {
                    for (let i = 0; i < gamepads.length; i++) {
                        if (gamepads[i]) {
                            handleGamepadConnected(gamepads[i]);
                            break;
                        }
                    }
                }
                return;
            }
            try {
                pollGamepadInput();
            } catch (error) {
                console.error('Error in gamepad polling:', error);
            }
            requestAnimationFrame(gamepadLoop);
        }
        // --- Initial Status Fetch ---
        async function fetchInitialStatus() {
            try {
                const response = await fetch('/status');
                const data = await response.json();
                if (data && data.state) {
                    motorStatusEl.textContent = `Status: ${data.state} | Speed Setting: ${data.speed}`;
                }
            } catch (error) {
                console.error('Error fetching initial status:', error);
                motorStatusEl.textContent = 'Status: Error connecting to car.';
            }
        }
        fetchInitialStatus();
        scanGamepads();
    </script>
</body>
</html>


